// This file is generated by rust-protobuf 2.14.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `mirrormanager.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_14_0;

#[derive(PartialEq,Clone,Default)]
pub struct FileDetailsType {
    // message fields
    TimeStamp: ::std::option::Option<u64>,
    Size: ::std::option::Option<u64>,
    SHA1: ::protobuf::SingularField<::std::string::String>,
    MD5: ::protobuf::SingularField<::std::string::String>,
    SHA256: ::protobuf::SingularField<::std::string::String>,
    SHA512: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileDetailsType {
    fn default() -> &'a FileDetailsType {
        <FileDetailsType as ::protobuf::Message>::default_instance()
    }
}

impl FileDetailsType {
    pub fn new() -> FileDetailsType {
        ::std::default::Default::default()
    }

    // required uint64 TimeStamp = 1;


    pub fn get_TimeStamp(&self) -> u64 {
        self.TimeStamp.unwrap_or(0)
    }
    pub fn clear_TimeStamp(&mut self) {
        self.TimeStamp = ::std::option::Option::None;
    }

    pub fn has_TimeStamp(&self) -> bool {
        self.TimeStamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_TimeStamp(&mut self, v: u64) {
        self.TimeStamp = ::std::option::Option::Some(v);
    }

    // required uint64 Size = 2;


    pub fn get_Size(&self) -> u64 {
        self.Size.unwrap_or(0)
    }
    pub fn clear_Size(&mut self) {
        self.Size = ::std::option::Option::None;
    }

    pub fn has_Size(&self) -> bool {
        self.Size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Size(&mut self, v: u64) {
        self.Size = ::std::option::Option::Some(v);
    }

    // optional string SHA1 = 3;


    pub fn get_SHA1(&self) -> &str {
        match self.SHA1.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_SHA1(&mut self) {
        self.SHA1.clear();
    }

    pub fn has_SHA1(&self) -> bool {
        self.SHA1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_SHA1(&mut self, v: ::std::string::String) {
        self.SHA1 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SHA1(&mut self) -> &mut ::std::string::String {
        if self.SHA1.is_none() {
            self.SHA1.set_default();
        }
        self.SHA1.as_mut().unwrap()
    }

    // Take field
    pub fn take_SHA1(&mut self) -> ::std::string::String {
        self.SHA1.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string MD5 = 4;


    pub fn get_MD5(&self) -> &str {
        match self.MD5.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_MD5(&mut self) {
        self.MD5.clear();
    }

    pub fn has_MD5(&self) -> bool {
        self.MD5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_MD5(&mut self, v: ::std::string::String) {
        self.MD5 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_MD5(&mut self) -> &mut ::std::string::String {
        if self.MD5.is_none() {
            self.MD5.set_default();
        }
        self.MD5.as_mut().unwrap()
    }

    // Take field
    pub fn take_MD5(&mut self) -> ::std::string::String {
        self.MD5.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string SHA256 = 5;


    pub fn get_SHA256(&self) -> &str {
        match self.SHA256.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_SHA256(&mut self) {
        self.SHA256.clear();
    }

    pub fn has_SHA256(&self) -> bool {
        self.SHA256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_SHA256(&mut self, v: ::std::string::String) {
        self.SHA256 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SHA256(&mut self) -> &mut ::std::string::String {
        if self.SHA256.is_none() {
            self.SHA256.set_default();
        }
        self.SHA256.as_mut().unwrap()
    }

    // Take field
    pub fn take_SHA256(&mut self) -> ::std::string::String {
        self.SHA256.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string SHA512 = 6;


    pub fn get_SHA512(&self) -> &str {
        match self.SHA512.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_SHA512(&mut self) {
        self.SHA512.clear();
    }

    pub fn has_SHA512(&self) -> bool {
        self.SHA512.is_some()
    }

    // Param is passed by value, moved
    pub fn set_SHA512(&mut self, v: ::std::string::String) {
        self.SHA512 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SHA512(&mut self) -> &mut ::std::string::String {
        if self.SHA512.is_none() {
            self.SHA512.set_default();
        }
        self.SHA512.as_mut().unwrap()
    }

    // Take field
    pub fn take_SHA512(&mut self) -> ::std::string::String {
        self.SHA512.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for FileDetailsType {
    fn is_initialized(&self) -> bool {
        if self.TimeStamp.is_none() {
            return false;
        }
        if self.Size.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.TimeStamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Size = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.SHA1)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.MD5)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.SHA256)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.SHA512)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.TimeStamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.Size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.SHA1.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.MD5.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.SHA256.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.SHA512.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.TimeStamp {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.Size {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.SHA1.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.MD5.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.SHA256.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.SHA512.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileDetailsType {
        FileDetailsType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "TimeStamp",
                    |m: &FileDetailsType| { &m.TimeStamp },
                    |m: &mut FileDetailsType| { &mut m.TimeStamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "Size",
                    |m: &FileDetailsType| { &m.Size },
                    |m: &mut FileDetailsType| { &mut m.Size },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "SHA1",
                    |m: &FileDetailsType| { &m.SHA1 },
                    |m: &mut FileDetailsType| { &mut m.SHA1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "MD5",
                    |m: &FileDetailsType| { &m.MD5 },
                    |m: &mut FileDetailsType| { &mut m.MD5 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "SHA256",
                    |m: &FileDetailsType| { &m.SHA256 },
                    |m: &mut FileDetailsType| { &mut m.SHA256 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "SHA512",
                    |m: &FileDetailsType| { &m.SHA512 },
                    |m: &mut FileDetailsType| { &mut m.SHA512 },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<FileDetailsType>(
                    "FileDetailsType",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FileDetailsType {
        static mut instance: ::protobuf::lazy::Lazy<FileDetailsType> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(FileDetailsType::new)
        }
    }
}

impl ::protobuf::Clear for FileDetailsType {
    fn clear(&mut self) {
        self.TimeStamp = ::std::option::Option::None;
        self.Size = ::std::option::Option::None;
        self.SHA1.clear();
        self.MD5.clear();
        self.SHA256.clear();
        self.SHA512.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileDetailsType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileDetailsType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FileDetailsCacheFilesType {
    // message fields
    filename: ::protobuf::SingularField<::std::string::String>,
    FileDetails: ::protobuf::RepeatedField<FileDetailsType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileDetailsCacheFilesType {
    fn default() -> &'a FileDetailsCacheFilesType {
        <FileDetailsCacheFilesType as ::protobuf::Message>::default_instance()
    }
}

impl FileDetailsCacheFilesType {
    pub fn new() -> FileDetailsCacheFilesType {
        ::std::default::Default::default()
    }

    // required string filename = 1;


    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .mirrormanager.FileDetailsType FileDetails = 2;


    pub fn get_FileDetails(&self) -> &[FileDetailsType] {
        &self.FileDetails
    }
    pub fn clear_FileDetails(&mut self) {
        self.FileDetails.clear();
    }

    // Param is passed by value, moved
    pub fn set_FileDetails(&mut self, v: ::protobuf::RepeatedField<FileDetailsType>) {
        self.FileDetails = v;
    }

    // Mutable pointer to the field.
    pub fn mut_FileDetails(&mut self) -> &mut ::protobuf::RepeatedField<FileDetailsType> {
        &mut self.FileDetails
    }

    // Take field
    pub fn take_FileDetails(&mut self) -> ::protobuf::RepeatedField<FileDetailsType> {
        ::std::mem::replace(&mut self.FileDetails, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for FileDetailsCacheFilesType {
    fn is_initialized(&self) -> bool {
        if self.filename.is_none() {
            return false;
        }
        for v in &self.FileDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.FileDetails)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.FileDetails {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filename.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.FileDetails {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileDetailsCacheFilesType {
        FileDetailsCacheFilesType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "filename",
                    |m: &FileDetailsCacheFilesType| { &m.filename },
                    |m: &mut FileDetailsCacheFilesType| { &mut m.filename },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileDetailsType>>(
                    "FileDetails",
                    |m: &FileDetailsCacheFilesType| { &m.FileDetails },
                    |m: &mut FileDetailsCacheFilesType| { &mut m.FileDetails },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<FileDetailsCacheFilesType>(
                    "FileDetailsCacheFilesType",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FileDetailsCacheFilesType {
        static mut instance: ::protobuf::lazy::Lazy<FileDetailsCacheFilesType> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(FileDetailsCacheFilesType::new)
        }
    }
}

impl ::protobuf::Clear for FileDetailsCacheFilesType {
    fn clear(&mut self) {
        self.filename.clear();
        self.FileDetails.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileDetailsCacheFilesType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileDetailsCacheFilesType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FileDetailsCacheDirectoryType {
    // message fields
    directory: ::protobuf::SingularField<::std::string::String>,
    FileDetailsCacheFiles: ::protobuf::RepeatedField<FileDetailsCacheFilesType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileDetailsCacheDirectoryType {
    fn default() -> &'a FileDetailsCacheDirectoryType {
        <FileDetailsCacheDirectoryType as ::protobuf::Message>::default_instance()
    }
}

impl FileDetailsCacheDirectoryType {
    pub fn new() -> FileDetailsCacheDirectoryType {
        ::std::default::Default::default()
    }

    // required string directory = 1;


    pub fn get_directory(&self) -> &str {
        match self.directory.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_directory(&mut self) {
        self.directory.clear();
    }

    pub fn has_directory(&self) -> bool {
        self.directory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directory(&mut self, v: ::std::string::String) {
        self.directory = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directory(&mut self) -> &mut ::std::string::String {
        if self.directory.is_none() {
            self.directory.set_default();
        }
        self.directory.as_mut().unwrap()
    }

    // Take field
    pub fn take_directory(&mut self) -> ::std::string::String {
        self.directory.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .mirrormanager.FileDetailsCacheFilesType FileDetailsCacheFiles = 2;


    pub fn get_FileDetailsCacheFiles(&self) -> &[FileDetailsCacheFilesType] {
        &self.FileDetailsCacheFiles
    }
    pub fn clear_FileDetailsCacheFiles(&mut self) {
        self.FileDetailsCacheFiles.clear();
    }

    // Param is passed by value, moved
    pub fn set_FileDetailsCacheFiles(&mut self, v: ::protobuf::RepeatedField<FileDetailsCacheFilesType>) {
        self.FileDetailsCacheFiles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_FileDetailsCacheFiles(&mut self) -> &mut ::protobuf::RepeatedField<FileDetailsCacheFilesType> {
        &mut self.FileDetailsCacheFiles
    }

    // Take field
    pub fn take_FileDetailsCacheFiles(&mut self) -> ::protobuf::RepeatedField<FileDetailsCacheFilesType> {
        ::std::mem::replace(&mut self.FileDetailsCacheFiles, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for FileDetailsCacheDirectoryType {
    fn is_initialized(&self) -> bool {
        if self.directory.is_none() {
            return false;
        }
        for v in &self.FileDetailsCacheFiles {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.directory)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.FileDetailsCacheFiles)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.directory.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.FileDetailsCacheFiles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.directory.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.FileDetailsCacheFiles {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileDetailsCacheDirectoryType {
        FileDetailsCacheDirectoryType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "directory",
                    |m: &FileDetailsCacheDirectoryType| { &m.directory },
                    |m: &mut FileDetailsCacheDirectoryType| { &mut m.directory },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileDetailsCacheFilesType>>(
                    "FileDetailsCacheFiles",
                    |m: &FileDetailsCacheDirectoryType| { &m.FileDetailsCacheFiles },
                    |m: &mut FileDetailsCacheDirectoryType| { &mut m.FileDetailsCacheFiles },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<FileDetailsCacheDirectoryType>(
                    "FileDetailsCacheDirectoryType",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FileDetailsCacheDirectoryType {
        static mut instance: ::protobuf::lazy::Lazy<FileDetailsCacheDirectoryType> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(FileDetailsCacheDirectoryType::new)
        }
    }
}

impl ::protobuf::Clear for FileDetailsCacheDirectoryType {
    fn clear(&mut self) {
        self.directory.clear();
        self.FileDetailsCacheFiles.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileDetailsCacheDirectoryType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileDetailsCacheDirectoryType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MirrorListCacheType {
    // message fields
    directory: ::protobuf::SingularField<::std::string::String>,
    Global: ::std::vec::Vec<i64>,
    Subpath: ::protobuf::SingularField<::std::string::String>,
    ByCountry: ::protobuf::RepeatedField<StringRepeatedIntMap>,
    ByCountryInternet2: ::protobuf::RepeatedField<StringRepeatedIntMap>,
    ByHostId: ::protobuf::RepeatedField<IntRepeatedIntMap>,
    OrderedMirrorList: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MirrorListCacheType {
    fn default() -> &'a MirrorListCacheType {
        <MirrorListCacheType as ::protobuf::Message>::default_instance()
    }
}

impl MirrorListCacheType {
    pub fn new() -> MirrorListCacheType {
        ::std::default::Default::default()
    }

    // required string directory = 1;


    pub fn get_directory(&self) -> &str {
        match self.directory.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_directory(&mut self) {
        self.directory.clear();
    }

    pub fn has_directory(&self) -> bool {
        self.directory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directory(&mut self, v: ::std::string::String) {
        self.directory = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directory(&mut self) -> &mut ::std::string::String {
        if self.directory.is_none() {
            self.directory.set_default();
        }
        self.directory.as_mut().unwrap()
    }

    // Take field
    pub fn take_directory(&mut self) -> ::std::string::String {
        self.directory.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated int64 Global = 2;


    pub fn get_Global(&self) -> &[i64] {
        &self.Global
    }
    pub fn clear_Global(&mut self) {
        self.Global.clear();
    }

    // Param is passed by value, moved
    pub fn set_Global(&mut self, v: ::std::vec::Vec<i64>) {
        self.Global = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Global(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.Global
    }

    // Take field
    pub fn take_Global(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.Global, ::std::vec::Vec::new())
    }

    // optional string Subpath = 3;


    pub fn get_Subpath(&self) -> &str {
        match self.Subpath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_Subpath(&mut self) {
        self.Subpath.clear();
    }

    pub fn has_Subpath(&self) -> bool {
        self.Subpath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Subpath(&mut self, v: ::std::string::String) {
        self.Subpath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Subpath(&mut self) -> &mut ::std::string::String {
        if self.Subpath.is_none() {
            self.Subpath.set_default();
        }
        self.Subpath.as_mut().unwrap()
    }

    // Take field
    pub fn take_Subpath(&mut self) -> ::std::string::String {
        self.Subpath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .mirrormanager.StringRepeatedIntMap ByCountry = 4;


    pub fn get_ByCountry(&self) -> &[StringRepeatedIntMap] {
        &self.ByCountry
    }
    pub fn clear_ByCountry(&mut self) {
        self.ByCountry.clear();
    }

    // Param is passed by value, moved
    pub fn set_ByCountry(&mut self, v: ::protobuf::RepeatedField<StringRepeatedIntMap>) {
        self.ByCountry = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ByCountry(&mut self) -> &mut ::protobuf::RepeatedField<StringRepeatedIntMap> {
        &mut self.ByCountry
    }

    // Take field
    pub fn take_ByCountry(&mut self) -> ::protobuf::RepeatedField<StringRepeatedIntMap> {
        ::std::mem::replace(&mut self.ByCountry, ::protobuf::RepeatedField::new())
    }

    // repeated .mirrormanager.StringRepeatedIntMap ByCountryInternet2 = 5;


    pub fn get_ByCountryInternet2(&self) -> &[StringRepeatedIntMap] {
        &self.ByCountryInternet2
    }
    pub fn clear_ByCountryInternet2(&mut self) {
        self.ByCountryInternet2.clear();
    }

    // Param is passed by value, moved
    pub fn set_ByCountryInternet2(&mut self, v: ::protobuf::RepeatedField<StringRepeatedIntMap>) {
        self.ByCountryInternet2 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ByCountryInternet2(&mut self) -> &mut ::protobuf::RepeatedField<StringRepeatedIntMap> {
        &mut self.ByCountryInternet2
    }

    // Take field
    pub fn take_ByCountryInternet2(&mut self) -> ::protobuf::RepeatedField<StringRepeatedIntMap> {
        ::std::mem::replace(&mut self.ByCountryInternet2, ::protobuf::RepeatedField::new())
    }

    // repeated .mirrormanager.IntRepeatedIntMap ByHostId = 6;


    pub fn get_ByHostId(&self) -> &[IntRepeatedIntMap] {
        &self.ByHostId
    }
    pub fn clear_ByHostId(&mut self) {
        self.ByHostId.clear();
    }

    // Param is passed by value, moved
    pub fn set_ByHostId(&mut self, v: ::protobuf::RepeatedField<IntRepeatedIntMap>) {
        self.ByHostId = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ByHostId(&mut self) -> &mut ::protobuf::RepeatedField<IntRepeatedIntMap> {
        &mut self.ByHostId
    }

    // Take field
    pub fn take_ByHostId(&mut self) -> ::protobuf::RepeatedField<IntRepeatedIntMap> {
        ::std::mem::replace(&mut self.ByHostId, ::protobuf::RepeatedField::new())
    }

    // optional bool OrderedMirrorList = 7;


    pub fn get_OrderedMirrorList(&self) -> bool {
        self.OrderedMirrorList.unwrap_or(false)
    }
    pub fn clear_OrderedMirrorList(&mut self) {
        self.OrderedMirrorList = ::std::option::Option::None;
    }

    pub fn has_OrderedMirrorList(&self) -> bool {
        self.OrderedMirrorList.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OrderedMirrorList(&mut self, v: bool) {
        self.OrderedMirrorList = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MirrorListCacheType {
    fn is_initialized(&self) -> bool {
        if self.directory.is_none() {
            return false;
        }
        for v in &self.ByCountry {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ByCountryInternet2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ByHostId {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.directory)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.Global)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.Subpath)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ByCountry)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ByCountryInternet2)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ByHostId)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.OrderedMirrorList = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.directory.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.Global {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.Subpath.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.ByCountry {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ByCountryInternet2 {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ByHostId {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.OrderedMirrorList {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.directory.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.Global {
            os.write_int64(2, *v)?;
        };
        if let Some(ref v) = self.Subpath.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.ByCountry {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ByCountryInternet2 {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ByHostId {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.OrderedMirrorList {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MirrorListCacheType {
        MirrorListCacheType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "directory",
                    |m: &MirrorListCacheType| { &m.directory },
                    |m: &mut MirrorListCacheType| { &mut m.directory },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "Global",
                    |m: &MirrorListCacheType| { &m.Global },
                    |m: &mut MirrorListCacheType| { &mut m.Global },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Subpath",
                    |m: &MirrorListCacheType| { &m.Subpath },
                    |m: &mut MirrorListCacheType| { &mut m.Subpath },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringRepeatedIntMap>>(
                    "ByCountry",
                    |m: &MirrorListCacheType| { &m.ByCountry },
                    |m: &mut MirrorListCacheType| { &mut m.ByCountry },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringRepeatedIntMap>>(
                    "ByCountryInternet2",
                    |m: &MirrorListCacheType| { &m.ByCountryInternet2 },
                    |m: &mut MirrorListCacheType| { &mut m.ByCountryInternet2 },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IntRepeatedIntMap>>(
                    "ByHostId",
                    |m: &MirrorListCacheType| { &m.ByHostId },
                    |m: &mut MirrorListCacheType| { &mut m.ByHostId },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "OrderedMirrorList",
                    |m: &MirrorListCacheType| { &m.OrderedMirrorList },
                    |m: &mut MirrorListCacheType| { &mut m.OrderedMirrorList },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<MirrorListCacheType>(
                    "MirrorListCacheType",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MirrorListCacheType {
        static mut instance: ::protobuf::lazy::Lazy<MirrorListCacheType> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(MirrorListCacheType::new)
        }
    }
}

impl ::protobuf::Clear for MirrorListCacheType {
    fn clear(&mut self) {
        self.directory.clear();
        self.Global.clear();
        self.Subpath.clear();
        self.ByCountry.clear();
        self.ByCountryInternet2.clear();
        self.ByHostId.clear();
        self.OrderedMirrorList = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MirrorListCacheType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MirrorListCacheType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StringStringMap {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StringStringMap {
    fn default() -> &'a StringStringMap {
        <StringStringMap as ::protobuf::Message>::default_instance()
    }
}

impl StringStringMap {
    pub fn new() -> StringStringMap {
        ::std::default::Default::default()
    }

    // required string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for StringStringMap {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StringStringMap {
        StringStringMap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    |m: &StringStringMap| { &m.key },
                    |m: &mut StringStringMap| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &StringStringMap| { &m.value },
                    |m: &mut StringStringMap| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<StringStringMap>(
                    "StringStringMap",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StringStringMap {
        static mut instance: ::protobuf::lazy::Lazy<StringStringMap> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(StringStringMap::new)
        }
    }
}

impl ::protobuf::Clear for StringStringMap {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StringStringMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringStringMap {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StringRepeatedIntMap {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::std::vec::Vec<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StringRepeatedIntMap {
    fn default() -> &'a StringRepeatedIntMap {
        <StringRepeatedIntMap as ::protobuf::Message>::default_instance()
    }
}

impl StringRepeatedIntMap {
    pub fn new() -> StringRepeatedIntMap {
        ::std::default::Default::default()
    }

    // required string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated int64 value = 2;


    pub fn get_value(&self) -> &[i64] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<i64>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for StringRepeatedIntMap {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.value {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.value {
            os.write_int64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StringRepeatedIntMap {
        StringRepeatedIntMap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    |m: &StringRepeatedIntMap| { &m.key },
                    |m: &mut StringRepeatedIntMap| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "value",
                    |m: &StringRepeatedIntMap| { &m.value },
                    |m: &mut StringRepeatedIntMap| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<StringRepeatedIntMap>(
                    "StringRepeatedIntMap",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StringRepeatedIntMap {
        static mut instance: ::protobuf::lazy::Lazy<StringRepeatedIntMap> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(StringRepeatedIntMap::new)
        }
    }
}

impl ::protobuf::Clear for StringRepeatedIntMap {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StringRepeatedIntMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringRepeatedIntMap {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IntRepeatedStringMap {
    // message fields
    key: ::std::option::Option<i64>,
    value: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IntRepeatedStringMap {
    fn default() -> &'a IntRepeatedStringMap {
        <IntRepeatedStringMap as ::protobuf::Message>::default_instance()
    }
}

impl IntRepeatedStringMap {
    pub fn new() -> IntRepeatedStringMap {
        ::std::default::Default::default()
    }

    // required int64 key = 1;


    pub fn get_key(&self) -> i64 {
        self.key.unwrap_or(0)
    }
    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: i64) {
        self.key = ::std::option::Option::Some(v);
    }

    // repeated string value = 2;


    pub fn get_value(&self) -> &[::std::string::String] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.value, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for IntRepeatedStringMap {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.key = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.key {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.value {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.key {
            os.write_int64(1, v)?;
        }
        for v in &self.value {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IntRepeatedStringMap {
        IntRepeatedStringMap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "key",
                    |m: &IntRepeatedStringMap| { &m.key },
                    |m: &mut IntRepeatedStringMap| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &IntRepeatedStringMap| { &m.value },
                    |m: &mut IntRepeatedStringMap| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<IntRepeatedStringMap>(
                    "IntRepeatedStringMap",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IntRepeatedStringMap {
        static mut instance: ::protobuf::lazy::Lazy<IntRepeatedStringMap> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(IntRepeatedStringMap::new)
        }
    }
}

impl ::protobuf::Clear for IntRepeatedStringMap {
    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IntRepeatedStringMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IntRepeatedStringMap {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IntStringMap {
    // message fields
    key: ::std::option::Option<i64>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IntStringMap {
    fn default() -> &'a IntStringMap {
        <IntStringMap as ::protobuf::Message>::default_instance()
    }
}

impl IntStringMap {
    pub fn new() -> IntStringMap {
        ::std::default::Default::default()
    }

    // required int64 key = 1;


    pub fn get_key(&self) -> i64 {
        self.key.unwrap_or(0)
    }
    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: i64) {
        self.key = ::std::option::Option::Some(v);
    }

    // required string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for IntStringMap {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.key = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.key {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.key {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IntStringMap {
        IntStringMap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "key",
                    |m: &IntStringMap| { &m.key },
                    |m: &mut IntStringMap| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &IntStringMap| { &m.value },
                    |m: &mut IntStringMap| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<IntStringMap>(
                    "IntStringMap",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IntStringMap {
        static mut instance: ::protobuf::lazy::Lazy<IntStringMap> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(IntStringMap::new)
        }
    }
}

impl ::protobuf::Clear for IntStringMap {
    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IntStringMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IntStringMap {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IntIntMap {
    // message fields
    key: ::std::option::Option<i64>,
    value: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IntIntMap {
    fn default() -> &'a IntIntMap {
        <IntIntMap as ::protobuf::Message>::default_instance()
    }
}

impl IntIntMap {
    pub fn new() -> IntIntMap {
        ::std::default::Default::default()
    }

    // required int64 key = 1;


    pub fn get_key(&self) -> i64 {
        self.key.unwrap_or(0)
    }
    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: i64) {
        self.key = ::std::option::Option::Some(v);
    }

    // required int64 value = 2;


    pub fn get_value(&self) -> i64 {
        self.value.unwrap_or(0)
    }
    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i64) {
        self.value = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for IntIntMap {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.key = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.key {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.key {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.value {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IntIntMap {
        IntIntMap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "key",
                    |m: &IntIntMap| { &m.key },
                    |m: &mut IntIntMap| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "value",
                    |m: &IntIntMap| { &m.value },
                    |m: &mut IntIntMap| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<IntIntMap>(
                    "IntIntMap",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IntIntMap {
        static mut instance: ::protobuf::lazy::Lazy<IntIntMap> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(IntIntMap::new)
        }
    }
}

impl ::protobuf::Clear for IntIntMap {
    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IntIntMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IntIntMap {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IntRepeatedIntMap {
    // message fields
    key: ::std::option::Option<i64>,
    value: ::std::vec::Vec<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IntRepeatedIntMap {
    fn default() -> &'a IntRepeatedIntMap {
        <IntRepeatedIntMap as ::protobuf::Message>::default_instance()
    }
}

impl IntRepeatedIntMap {
    pub fn new() -> IntRepeatedIntMap {
        ::std::default::Default::default()
    }

    // required int64 key = 1;


    pub fn get_key(&self) -> i64 {
        self.key.unwrap_or(0)
    }
    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: i64) {
        self.key = ::std::option::Option::Some(v);
    }

    // repeated int64 value = 2;


    pub fn get_value(&self) -> &[i64] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<i64>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for IntRepeatedIntMap {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.key = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.key {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.value {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.key {
            os.write_int64(1, v)?;
        }
        for v in &self.value {
            os.write_int64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IntRepeatedIntMap {
        IntRepeatedIntMap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "key",
                    |m: &IntRepeatedIntMap| { &m.key },
                    |m: &mut IntRepeatedIntMap| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "value",
                    |m: &IntRepeatedIntMap| { &m.value },
                    |m: &mut IntRepeatedIntMap| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<IntRepeatedIntMap>(
                    "IntRepeatedIntMap",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IntRepeatedIntMap {
        static mut instance: ::protobuf::lazy::Lazy<IntRepeatedIntMap> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(IntRepeatedIntMap::new)
        }
    }
}

impl ::protobuf::Clear for IntRepeatedIntMap {
    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IntRepeatedIntMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IntRepeatedIntMap {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StringBoolMap {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StringBoolMap {
    fn default() -> &'a StringBoolMap {
        <StringBoolMap as ::protobuf::Message>::default_instance()
    }
}

impl StringBoolMap {
    pub fn new() -> StringBoolMap {
        ::std::default::Default::default()
    }

    // required string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bool value = 2;


    pub fn get_value(&self) -> bool {
        self.value.unwrap_or(false)
    }
    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: bool) {
        self.value = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for StringBoolMap {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.value {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StringBoolMap {
        StringBoolMap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    |m: &StringBoolMap| { &m.key },
                    |m: &mut StringBoolMap| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "value",
                    |m: &StringBoolMap| { &m.value },
                    |m: &mut StringBoolMap| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<StringBoolMap>(
                    "StringBoolMap",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StringBoolMap {
        static mut instance: ::protobuf::lazy::Lazy<StringBoolMap> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(StringBoolMap::new)
        }
    }
}

impl ::protobuf::Clear for StringBoolMap {
    fn clear(&mut self) {
        self.key.clear();
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StringBoolMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringBoolMap {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MirrorList {
    // message fields
    Time: ::std::option::Option<u64>,
    NetblockCountryCache: ::protobuf::RepeatedField<StringStringMap>,
    LocationCache: ::protobuf::RepeatedField<StringRepeatedIntMap>,
    HCUrlCache: ::protobuf::RepeatedField<IntStringMap>,
    FileDetailsCache: ::protobuf::RepeatedField<FileDetailsCacheDirectoryType>,
    DisabledRepositoryCache: ::protobuf::RepeatedField<StringBoolMap>,
    CountryContinentRedirectCache: ::protobuf::RepeatedField<StringStringMap>,
    RepositoryRedirectCache: ::protobuf::RepeatedField<StringStringMap>,
    RepoArchToDirectoryName: ::protobuf::RepeatedField<StringStringMap>,
    HostAsnCache: ::protobuf::RepeatedField<IntRepeatedIntMap>,
    HostMaxConnectionCache: ::protobuf::RepeatedField<IntIntMap>,
    HostCountryCache: ::protobuf::RepeatedField<IntStringMap>,
    HostBandwidthCache: ::protobuf::RepeatedField<IntIntMap>,
    HostCountryAllowedCache: ::protobuf::RepeatedField<IntRepeatedStringMap>,
    HostNetblockCache: ::protobuf::RepeatedField<StringRepeatedIntMap>,
    MirrorListCache: ::protobuf::RepeatedField<MirrorListCacheType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MirrorList {
    fn default() -> &'a MirrorList {
        <MirrorList as ::protobuf::Message>::default_instance()
    }
}

impl MirrorList {
    pub fn new() -> MirrorList {
        ::std::default::Default::default()
    }

    // required uint64 Time = 1;


    pub fn get_Time(&self) -> u64 {
        self.Time.unwrap_or(0)
    }
    pub fn clear_Time(&mut self) {
        self.Time = ::std::option::Option::None;
    }

    pub fn has_Time(&self) -> bool {
        self.Time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Time(&mut self, v: u64) {
        self.Time = ::std::option::Option::Some(v);
    }

    // repeated .mirrormanager.StringStringMap NetblockCountryCache = 2;


    pub fn get_NetblockCountryCache(&self) -> &[StringStringMap] {
        &self.NetblockCountryCache
    }
    pub fn clear_NetblockCountryCache(&mut self) {
        self.NetblockCountryCache.clear();
    }

    // Param is passed by value, moved
    pub fn set_NetblockCountryCache(&mut self, v: ::protobuf::RepeatedField<StringStringMap>) {
        self.NetblockCountryCache = v;
    }

    // Mutable pointer to the field.
    pub fn mut_NetblockCountryCache(&mut self) -> &mut ::protobuf::RepeatedField<StringStringMap> {
        &mut self.NetblockCountryCache
    }

    // Take field
    pub fn take_NetblockCountryCache(&mut self) -> ::protobuf::RepeatedField<StringStringMap> {
        ::std::mem::replace(&mut self.NetblockCountryCache, ::protobuf::RepeatedField::new())
    }

    // repeated .mirrormanager.StringRepeatedIntMap LocationCache = 3;


    pub fn get_LocationCache(&self) -> &[StringRepeatedIntMap] {
        &self.LocationCache
    }
    pub fn clear_LocationCache(&mut self) {
        self.LocationCache.clear();
    }

    // Param is passed by value, moved
    pub fn set_LocationCache(&mut self, v: ::protobuf::RepeatedField<StringRepeatedIntMap>) {
        self.LocationCache = v;
    }

    // Mutable pointer to the field.
    pub fn mut_LocationCache(&mut self) -> &mut ::protobuf::RepeatedField<StringRepeatedIntMap> {
        &mut self.LocationCache
    }

    // Take field
    pub fn take_LocationCache(&mut self) -> ::protobuf::RepeatedField<StringRepeatedIntMap> {
        ::std::mem::replace(&mut self.LocationCache, ::protobuf::RepeatedField::new())
    }

    // repeated .mirrormanager.IntStringMap HCUrlCache = 4;


    pub fn get_HCUrlCache(&self) -> &[IntStringMap] {
        &self.HCUrlCache
    }
    pub fn clear_HCUrlCache(&mut self) {
        self.HCUrlCache.clear();
    }

    // Param is passed by value, moved
    pub fn set_HCUrlCache(&mut self, v: ::protobuf::RepeatedField<IntStringMap>) {
        self.HCUrlCache = v;
    }

    // Mutable pointer to the field.
    pub fn mut_HCUrlCache(&mut self) -> &mut ::protobuf::RepeatedField<IntStringMap> {
        &mut self.HCUrlCache
    }

    // Take field
    pub fn take_HCUrlCache(&mut self) -> ::protobuf::RepeatedField<IntStringMap> {
        ::std::mem::replace(&mut self.HCUrlCache, ::protobuf::RepeatedField::new())
    }

    // repeated .mirrormanager.FileDetailsCacheDirectoryType FileDetailsCache = 5;


    pub fn get_FileDetailsCache(&self) -> &[FileDetailsCacheDirectoryType] {
        &self.FileDetailsCache
    }
    pub fn clear_FileDetailsCache(&mut self) {
        self.FileDetailsCache.clear();
    }

    // Param is passed by value, moved
    pub fn set_FileDetailsCache(&mut self, v: ::protobuf::RepeatedField<FileDetailsCacheDirectoryType>) {
        self.FileDetailsCache = v;
    }

    // Mutable pointer to the field.
    pub fn mut_FileDetailsCache(&mut self) -> &mut ::protobuf::RepeatedField<FileDetailsCacheDirectoryType> {
        &mut self.FileDetailsCache
    }

    // Take field
    pub fn take_FileDetailsCache(&mut self) -> ::protobuf::RepeatedField<FileDetailsCacheDirectoryType> {
        ::std::mem::replace(&mut self.FileDetailsCache, ::protobuf::RepeatedField::new())
    }

    // repeated .mirrormanager.StringBoolMap DisabledRepositoryCache = 6;


    pub fn get_DisabledRepositoryCache(&self) -> &[StringBoolMap] {
        &self.DisabledRepositoryCache
    }
    pub fn clear_DisabledRepositoryCache(&mut self) {
        self.DisabledRepositoryCache.clear();
    }

    // Param is passed by value, moved
    pub fn set_DisabledRepositoryCache(&mut self, v: ::protobuf::RepeatedField<StringBoolMap>) {
        self.DisabledRepositoryCache = v;
    }

    // Mutable pointer to the field.
    pub fn mut_DisabledRepositoryCache(&mut self) -> &mut ::protobuf::RepeatedField<StringBoolMap> {
        &mut self.DisabledRepositoryCache
    }

    // Take field
    pub fn take_DisabledRepositoryCache(&mut self) -> ::protobuf::RepeatedField<StringBoolMap> {
        ::std::mem::replace(&mut self.DisabledRepositoryCache, ::protobuf::RepeatedField::new())
    }

    // repeated .mirrormanager.StringStringMap CountryContinentRedirectCache = 7;


    pub fn get_CountryContinentRedirectCache(&self) -> &[StringStringMap] {
        &self.CountryContinentRedirectCache
    }
    pub fn clear_CountryContinentRedirectCache(&mut self) {
        self.CountryContinentRedirectCache.clear();
    }

    // Param is passed by value, moved
    pub fn set_CountryContinentRedirectCache(&mut self, v: ::protobuf::RepeatedField<StringStringMap>) {
        self.CountryContinentRedirectCache = v;
    }

    // Mutable pointer to the field.
    pub fn mut_CountryContinentRedirectCache(&mut self) -> &mut ::protobuf::RepeatedField<StringStringMap> {
        &mut self.CountryContinentRedirectCache
    }

    // Take field
    pub fn take_CountryContinentRedirectCache(&mut self) -> ::protobuf::RepeatedField<StringStringMap> {
        ::std::mem::replace(&mut self.CountryContinentRedirectCache, ::protobuf::RepeatedField::new())
    }

    // repeated .mirrormanager.StringStringMap RepositoryRedirectCache = 8;


    pub fn get_RepositoryRedirectCache(&self) -> &[StringStringMap] {
        &self.RepositoryRedirectCache
    }
    pub fn clear_RepositoryRedirectCache(&mut self) {
        self.RepositoryRedirectCache.clear();
    }

    // Param is passed by value, moved
    pub fn set_RepositoryRedirectCache(&mut self, v: ::protobuf::RepeatedField<StringStringMap>) {
        self.RepositoryRedirectCache = v;
    }

    // Mutable pointer to the field.
    pub fn mut_RepositoryRedirectCache(&mut self) -> &mut ::protobuf::RepeatedField<StringStringMap> {
        &mut self.RepositoryRedirectCache
    }

    // Take field
    pub fn take_RepositoryRedirectCache(&mut self) -> ::protobuf::RepeatedField<StringStringMap> {
        ::std::mem::replace(&mut self.RepositoryRedirectCache, ::protobuf::RepeatedField::new())
    }

    // repeated .mirrormanager.StringStringMap RepoArchToDirectoryName = 9;


    pub fn get_RepoArchToDirectoryName(&self) -> &[StringStringMap] {
        &self.RepoArchToDirectoryName
    }
    pub fn clear_RepoArchToDirectoryName(&mut self) {
        self.RepoArchToDirectoryName.clear();
    }

    // Param is passed by value, moved
    pub fn set_RepoArchToDirectoryName(&mut self, v: ::protobuf::RepeatedField<StringStringMap>) {
        self.RepoArchToDirectoryName = v;
    }

    // Mutable pointer to the field.
    pub fn mut_RepoArchToDirectoryName(&mut self) -> &mut ::protobuf::RepeatedField<StringStringMap> {
        &mut self.RepoArchToDirectoryName
    }

    // Take field
    pub fn take_RepoArchToDirectoryName(&mut self) -> ::protobuf::RepeatedField<StringStringMap> {
        ::std::mem::replace(&mut self.RepoArchToDirectoryName, ::protobuf::RepeatedField::new())
    }

    // repeated .mirrormanager.IntRepeatedIntMap HostAsnCache = 10;


    pub fn get_HostAsnCache(&self) -> &[IntRepeatedIntMap] {
        &self.HostAsnCache
    }
    pub fn clear_HostAsnCache(&mut self) {
        self.HostAsnCache.clear();
    }

    // Param is passed by value, moved
    pub fn set_HostAsnCache(&mut self, v: ::protobuf::RepeatedField<IntRepeatedIntMap>) {
        self.HostAsnCache = v;
    }

    // Mutable pointer to the field.
    pub fn mut_HostAsnCache(&mut self) -> &mut ::protobuf::RepeatedField<IntRepeatedIntMap> {
        &mut self.HostAsnCache
    }

    // Take field
    pub fn take_HostAsnCache(&mut self) -> ::protobuf::RepeatedField<IntRepeatedIntMap> {
        ::std::mem::replace(&mut self.HostAsnCache, ::protobuf::RepeatedField::new())
    }

    // repeated .mirrormanager.IntIntMap HostMaxConnectionCache = 11;


    pub fn get_HostMaxConnectionCache(&self) -> &[IntIntMap] {
        &self.HostMaxConnectionCache
    }
    pub fn clear_HostMaxConnectionCache(&mut self) {
        self.HostMaxConnectionCache.clear();
    }

    // Param is passed by value, moved
    pub fn set_HostMaxConnectionCache(&mut self, v: ::protobuf::RepeatedField<IntIntMap>) {
        self.HostMaxConnectionCache = v;
    }

    // Mutable pointer to the field.
    pub fn mut_HostMaxConnectionCache(&mut self) -> &mut ::protobuf::RepeatedField<IntIntMap> {
        &mut self.HostMaxConnectionCache
    }

    // Take field
    pub fn take_HostMaxConnectionCache(&mut self) -> ::protobuf::RepeatedField<IntIntMap> {
        ::std::mem::replace(&mut self.HostMaxConnectionCache, ::protobuf::RepeatedField::new())
    }

    // repeated .mirrormanager.IntStringMap HostCountryCache = 12;


    pub fn get_HostCountryCache(&self) -> &[IntStringMap] {
        &self.HostCountryCache
    }
    pub fn clear_HostCountryCache(&mut self) {
        self.HostCountryCache.clear();
    }

    // Param is passed by value, moved
    pub fn set_HostCountryCache(&mut self, v: ::protobuf::RepeatedField<IntStringMap>) {
        self.HostCountryCache = v;
    }

    // Mutable pointer to the field.
    pub fn mut_HostCountryCache(&mut self) -> &mut ::protobuf::RepeatedField<IntStringMap> {
        &mut self.HostCountryCache
    }

    // Take field
    pub fn take_HostCountryCache(&mut self) -> ::protobuf::RepeatedField<IntStringMap> {
        ::std::mem::replace(&mut self.HostCountryCache, ::protobuf::RepeatedField::new())
    }

    // repeated .mirrormanager.IntIntMap HostBandwidthCache = 13;


    pub fn get_HostBandwidthCache(&self) -> &[IntIntMap] {
        &self.HostBandwidthCache
    }
    pub fn clear_HostBandwidthCache(&mut self) {
        self.HostBandwidthCache.clear();
    }

    // Param is passed by value, moved
    pub fn set_HostBandwidthCache(&mut self, v: ::protobuf::RepeatedField<IntIntMap>) {
        self.HostBandwidthCache = v;
    }

    // Mutable pointer to the field.
    pub fn mut_HostBandwidthCache(&mut self) -> &mut ::protobuf::RepeatedField<IntIntMap> {
        &mut self.HostBandwidthCache
    }

    // Take field
    pub fn take_HostBandwidthCache(&mut self) -> ::protobuf::RepeatedField<IntIntMap> {
        ::std::mem::replace(&mut self.HostBandwidthCache, ::protobuf::RepeatedField::new())
    }

    // repeated .mirrormanager.IntRepeatedStringMap HostCountryAllowedCache = 14;


    pub fn get_HostCountryAllowedCache(&self) -> &[IntRepeatedStringMap] {
        &self.HostCountryAllowedCache
    }
    pub fn clear_HostCountryAllowedCache(&mut self) {
        self.HostCountryAllowedCache.clear();
    }

    // Param is passed by value, moved
    pub fn set_HostCountryAllowedCache(&mut self, v: ::protobuf::RepeatedField<IntRepeatedStringMap>) {
        self.HostCountryAllowedCache = v;
    }

    // Mutable pointer to the field.
    pub fn mut_HostCountryAllowedCache(&mut self) -> &mut ::protobuf::RepeatedField<IntRepeatedStringMap> {
        &mut self.HostCountryAllowedCache
    }

    // Take field
    pub fn take_HostCountryAllowedCache(&mut self) -> ::protobuf::RepeatedField<IntRepeatedStringMap> {
        ::std::mem::replace(&mut self.HostCountryAllowedCache, ::protobuf::RepeatedField::new())
    }

    // repeated .mirrormanager.StringRepeatedIntMap HostNetblockCache = 15;


    pub fn get_HostNetblockCache(&self) -> &[StringRepeatedIntMap] {
        &self.HostNetblockCache
    }
    pub fn clear_HostNetblockCache(&mut self) {
        self.HostNetblockCache.clear();
    }

    // Param is passed by value, moved
    pub fn set_HostNetblockCache(&mut self, v: ::protobuf::RepeatedField<StringRepeatedIntMap>) {
        self.HostNetblockCache = v;
    }

    // Mutable pointer to the field.
    pub fn mut_HostNetblockCache(&mut self) -> &mut ::protobuf::RepeatedField<StringRepeatedIntMap> {
        &mut self.HostNetblockCache
    }

    // Take field
    pub fn take_HostNetblockCache(&mut self) -> ::protobuf::RepeatedField<StringRepeatedIntMap> {
        ::std::mem::replace(&mut self.HostNetblockCache, ::protobuf::RepeatedField::new())
    }

    // repeated .mirrormanager.MirrorListCacheType MirrorListCache = 16;


    pub fn get_MirrorListCache(&self) -> &[MirrorListCacheType] {
        &self.MirrorListCache
    }
    pub fn clear_MirrorListCache(&mut self) {
        self.MirrorListCache.clear();
    }

    // Param is passed by value, moved
    pub fn set_MirrorListCache(&mut self, v: ::protobuf::RepeatedField<MirrorListCacheType>) {
        self.MirrorListCache = v;
    }

    // Mutable pointer to the field.
    pub fn mut_MirrorListCache(&mut self) -> &mut ::protobuf::RepeatedField<MirrorListCacheType> {
        &mut self.MirrorListCache
    }

    // Take field
    pub fn take_MirrorListCache(&mut self) -> ::protobuf::RepeatedField<MirrorListCacheType> {
        ::std::mem::replace(&mut self.MirrorListCache, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MirrorList {
    fn is_initialized(&self) -> bool {
        if self.Time.is_none() {
            return false;
        }
        for v in &self.NetblockCountryCache {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.LocationCache {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.HCUrlCache {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.FileDetailsCache {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.DisabledRepositoryCache {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.CountryContinentRedirectCache {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.RepositoryRedirectCache {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.RepoArchToDirectoryName {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.HostAsnCache {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.HostMaxConnectionCache {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.HostCountryCache {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.HostBandwidthCache {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.HostCountryAllowedCache {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.HostNetblockCache {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.MirrorListCache {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Time = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.NetblockCountryCache)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.LocationCache)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.HCUrlCache)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.FileDetailsCache)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.DisabledRepositoryCache)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.CountryContinentRedirectCache)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.RepositoryRedirectCache)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.RepoArchToDirectoryName)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.HostAsnCache)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.HostMaxConnectionCache)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.HostCountryCache)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.HostBandwidthCache)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.HostCountryAllowedCache)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.HostNetblockCache)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.MirrorListCache)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.Time {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.NetblockCountryCache {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.LocationCache {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.HCUrlCache {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.FileDetailsCache {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.DisabledRepositoryCache {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.CountryContinentRedirectCache {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.RepositoryRedirectCache {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.RepoArchToDirectoryName {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.HostAsnCache {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.HostMaxConnectionCache {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.HostCountryCache {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.HostBandwidthCache {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.HostCountryAllowedCache {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.HostNetblockCache {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.MirrorListCache {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.Time {
            os.write_uint64(1, v)?;
        }
        for v in &self.NetblockCountryCache {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.LocationCache {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.HCUrlCache {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.FileDetailsCache {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.DisabledRepositoryCache {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.CountryContinentRedirectCache {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.RepositoryRedirectCache {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.RepoArchToDirectoryName {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.HostAsnCache {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.HostMaxConnectionCache {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.HostCountryCache {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.HostBandwidthCache {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.HostCountryAllowedCache {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.HostNetblockCache {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.MirrorListCache {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MirrorList {
        MirrorList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "Time",
                    |m: &MirrorList| { &m.Time },
                    |m: &mut MirrorList| { &mut m.Time },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringStringMap>>(
                    "NetblockCountryCache",
                    |m: &MirrorList| { &m.NetblockCountryCache },
                    |m: &mut MirrorList| { &mut m.NetblockCountryCache },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringRepeatedIntMap>>(
                    "LocationCache",
                    |m: &MirrorList| { &m.LocationCache },
                    |m: &mut MirrorList| { &mut m.LocationCache },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IntStringMap>>(
                    "HCUrlCache",
                    |m: &MirrorList| { &m.HCUrlCache },
                    |m: &mut MirrorList| { &mut m.HCUrlCache },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileDetailsCacheDirectoryType>>(
                    "FileDetailsCache",
                    |m: &MirrorList| { &m.FileDetailsCache },
                    |m: &mut MirrorList| { &mut m.FileDetailsCache },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringBoolMap>>(
                    "DisabledRepositoryCache",
                    |m: &MirrorList| { &m.DisabledRepositoryCache },
                    |m: &mut MirrorList| { &mut m.DisabledRepositoryCache },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringStringMap>>(
                    "CountryContinentRedirectCache",
                    |m: &MirrorList| { &m.CountryContinentRedirectCache },
                    |m: &mut MirrorList| { &mut m.CountryContinentRedirectCache },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringStringMap>>(
                    "RepositoryRedirectCache",
                    |m: &MirrorList| { &m.RepositoryRedirectCache },
                    |m: &mut MirrorList| { &mut m.RepositoryRedirectCache },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringStringMap>>(
                    "RepoArchToDirectoryName",
                    |m: &MirrorList| { &m.RepoArchToDirectoryName },
                    |m: &mut MirrorList| { &mut m.RepoArchToDirectoryName },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IntRepeatedIntMap>>(
                    "HostAsnCache",
                    |m: &MirrorList| { &m.HostAsnCache },
                    |m: &mut MirrorList| { &mut m.HostAsnCache },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IntIntMap>>(
                    "HostMaxConnectionCache",
                    |m: &MirrorList| { &m.HostMaxConnectionCache },
                    |m: &mut MirrorList| { &mut m.HostMaxConnectionCache },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IntStringMap>>(
                    "HostCountryCache",
                    |m: &MirrorList| { &m.HostCountryCache },
                    |m: &mut MirrorList| { &mut m.HostCountryCache },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IntIntMap>>(
                    "HostBandwidthCache",
                    |m: &MirrorList| { &m.HostBandwidthCache },
                    |m: &mut MirrorList| { &mut m.HostBandwidthCache },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IntRepeatedStringMap>>(
                    "HostCountryAllowedCache",
                    |m: &MirrorList| { &m.HostCountryAllowedCache },
                    |m: &mut MirrorList| { &mut m.HostCountryAllowedCache },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StringRepeatedIntMap>>(
                    "HostNetblockCache",
                    |m: &MirrorList| { &m.HostNetblockCache },
                    |m: &mut MirrorList| { &mut m.HostNetblockCache },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MirrorListCacheType>>(
                    "MirrorListCache",
                    |m: &MirrorList| { &m.MirrorListCache },
                    |m: &mut MirrorList| { &mut m.MirrorListCache },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<MirrorList>(
                    "MirrorList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MirrorList {
        static mut instance: ::protobuf::lazy::Lazy<MirrorList> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(MirrorList::new)
        }
    }
}

impl ::protobuf::Clear for MirrorList {
    fn clear(&mut self) {
        self.Time = ::std::option::Option::None;
        self.NetblockCountryCache.clear();
        self.LocationCache.clear();
        self.HCUrlCache.clear();
        self.FileDetailsCache.clear();
        self.DisabledRepositoryCache.clear();
        self.CountryContinentRedirectCache.clear();
        self.RepositoryRedirectCache.clear();
        self.RepoArchToDirectoryName.clear();
        self.HostAsnCache.clear();
        self.HostMaxConnectionCache.clear();
        self.HostCountryCache.clear();
        self.HostBandwidthCache.clear();
        self.HostCountryAllowedCache.clear();
        self.HostNetblockCache.clear();
        self.MirrorListCache.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MirrorList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MirrorList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x13mirrormanager.proto\x12\rmirrormanager\"{\n\x0fFileDetailsType\x12\
    \x13\n\tTimeStamp\x18\x01\x20\x02(\x04B\0\x12\x0e\n\x04Size\x18\x02\x20\
    \x02(\x04B\0\x12\x0e\n\x04SHA1\x18\x03\x20\x01(\tB\0\x12\r\n\x03MD5\x18\
    \x04\x20\x01(\tB\0\x12\x10\n\x06SHA256\x18\x05\x20\x01(\tB\0\x12\x10\n\
    \x06SHA512\x18\x06\x20\x01(\tB\0:\0\"h\n\x19FileDetailsCacheFilesType\
    \x12\x12\n\x08filename\x18\x01\x20\x02(\tB\0\x125\n\x0bFileDetails\x18\
    \x02\x20\x03(\x0b2\x1e.mirrormanager.FileDetailsTypeB\0:\0\"\x81\x01\n\
    \x1dFileDetailsCacheDirectoryType\x12\x13\n\tdirectory\x18\x01\x20\x02(\
    \tB\0\x12I\n\x15FileDetailsCacheFiles\x18\x02\x20\x03(\x0b2(.mirrormanag\
    er.FileDetailsCacheFilesTypeB\0:\0\"\xa1\x02\n\x13MirrorListCacheType\
    \x12\x13\n\tdirectory\x18\x01\x20\x02(\tB\0\x12\x10\n\x06Global\x18\x02\
    \x20\x03(\x03B\0\x12\x11\n\x07Subpath\x18\x03\x20\x01(\tB\0\x128\n\tByCo\
    untry\x18\x04\x20\x03(\x0b2#.mirrormanager.StringRepeatedIntMapB\0\x12A\
    \n\x12ByCountryInternet2\x18\x05\x20\x03(\x0b2#.mirrormanager.StringRepe\
    atedIntMapB\0\x124\n\x08ByHostId\x18\x06\x20\x03(\x0b2\x20.mirrormanager\
    .IntRepeatedIntMapB\0\x12\x1b\n\x11OrderedMirrorList\x18\x07\x20\x01(\
    \x08B\0:\0\"3\n\x0fStringStringMap\x12\r\n\x03key\x18\x01\x20\x02(\tB\0\
    \x12\x0f\n\x05value\x18\x02\x20\x02(\tB\0:\0\"8\n\x14StringRepeatedIntMa\
    p\x12\r\n\x03key\x18\x01\x20\x02(\tB\0\x12\x0f\n\x05value\x18\x02\x20\
    \x03(\x03B\0:\0\"8\n\x14IntRepeatedStringMap\x12\r\n\x03key\x18\x01\x20\
    \x02(\x03B\0\x12\x0f\n\x05value\x18\x02\x20\x03(\tB\0:\0\"0\n\x0cIntStri\
    ngMap\x12\r\n\x03key\x18\x01\x20\x02(\x03B\0\x12\x0f\n\x05value\x18\x02\
    \x20\x02(\tB\0:\0\"-\n\tIntIntMap\x12\r\n\x03key\x18\x01\x20\x02(\x03B\0\
    \x12\x0f\n\x05value\x18\x02\x20\x02(\x03B\0:\0\"5\n\x11IntRepeatedIntMap\
    \x12\r\n\x03key\x18\x01\x20\x02(\x03B\0\x12\x0f\n\x05value\x18\x02\x20\
    \x03(\x03B\0:\0\"1\n\rStringBoolMap\x12\r\n\x03key\x18\x01\x20\x02(\tB\0\
    \x12\x0f\n\x05value\x18\x02\x20\x02(\x08B\0:\0\"\xd9\x07\n\nMirrorList\
    \x12\x0e\n\x04Time\x18\x01\x20\x02(\x04B\0\x12>\n\x14NetblockCountryCach\
    e\x18\x02\x20\x03(\x0b2\x1e.mirrormanager.StringStringMapB\0\x12<\n\rLoc\
    ationCache\x18\x03\x20\x03(\x0b2#.mirrormanager.StringRepeatedIntMapB\0\
    \x121\n\nHCUrlCache\x18\x04\x20\x03(\x0b2\x1b.mirrormanager.IntStringMap\
    B\0\x12H\n\x10FileDetailsCache\x18\x05\x20\x03(\x0b2,.mirrormanager.File\
    DetailsCacheDirectoryTypeB\0\x12?\n\x17DisabledRepositoryCache\x18\x06\
    \x20\x03(\x0b2\x1c.mirrormanager.StringBoolMapB\0\x12G\n\x1dCountryConti\
    nentRedirectCache\x18\x07\x20\x03(\x0b2\x1e.mirrormanager.StringStringMa\
    pB\0\x12A\n\x17RepositoryRedirectCache\x18\x08\x20\x03(\x0b2\x1e.mirrorm\
    anager.StringStringMapB\0\x12A\n\x17RepoArchToDirectoryName\x18\t\x20\
    \x03(\x0b2\x1e.mirrormanager.StringStringMapB\0\x128\n\x0cHostAsnCache\
    \x18\n\x20\x03(\x0b2\x20.mirrormanager.IntRepeatedIntMapB\0\x12:\n\x16Ho\
    stMaxConnectionCache\x18\x0b\x20\x03(\x0b2\x18.mirrormanager.IntIntMapB\
    \0\x127\n\x10HostCountryCache\x18\x0c\x20\x03(\x0b2\x1b.mirrormanager.In\
    tStringMapB\0\x126\n\x12HostBandwidthCache\x18\r\x20\x03(\x0b2\x18.mirro\
    rmanager.IntIntMapB\0\x12F\n\x17HostCountryAllowedCache\x18\x0e\x20\x03(\
    \x0b2#.mirrormanager.IntRepeatedStringMapB\0\x12@\n\x11HostNetblockCache\
    \x18\x0f\x20\x03(\x0b2#.mirrormanager.StringRepeatedIntMapB\0\x12=\n\x0f\
    MirrorListCache\x18\x10\x20\x03(\x0b2\".mirrormanager.MirrorListCacheTyp\
    eB\0:\0B\0b\x06proto2\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
